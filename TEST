import numpy as np
import struct
from MEC1315_STL import *


def centrer(v): #Permet de centrer le stl en(0,0,0)
    v[:,0]=v[:,0]-(max(v[:,0])+min(v[:,0]))/2 #centre axe x
    v[:,1]=v[:,1]-(max(v[:,1])+min(v[:,1]))/2 #centre axe y
    v[:,2]=v[:,2]-(max(v[:,2])+min(v[:,2]))/2 #centre axe z
    return v

def grandeur(x,y,z,v): #Permet de changer l'échelle du stl (homothétie), Dois utiliser centrer avant
    v[:,0]=v[:,0]/(max(v[:,0])-min(v[:,0]))*x #mise à l'échelle composant x
    v[:,1]=v[:,1]/(max(v[:,1])-min(v[:,1]))*y #mise à l'échelle composant y
    v[:,2]=v[:,2]/(max(v[:,2])-min(v[:,2]))*z #mise à l'échelle composant z
    return v

def emplacement(x,y,z,v): #Permet de déplacer le stl
    v[:,0]=v[:,0]-(max(v[:,0])+min(v[:,0]))/2+x #déplacement en x
    v[:,1]=v[:,1]-(max(v[:,1])+min(v[:,1]))/2+y #déplacement en y
    v[:,2]=v[:,2]-(max(v[:,2])+min(v[:,2]))/2+z #déplacement en z
    return v
    
def rotation(v,angle,axe): #Permet de tourner le stl
    if axe =="z": #Tourne sur l'axe z
        v=v.dot(np.array([[np.cos(angle),np.sin(angle),0],[-np.sin(angle),np.cos(angle),0],[0,0,1]]))
    elif axe == "y": #Tourne sur l'axe y
        v=v.dot(np.array([[np.cos(angle),0,np.sin(angle)],[0,1,0],[-np.sin(angle),0,np.cos(angle)]]))
    elif axe == "x": #Tourne sur l'axe x
        v=v.dot(np.array([[1,0,0],[0,np.cos(angle),np.sin(angle)],[0,-np.sin(angle),np.cos(angle)]]))
    return v

def acote_plan(v,plan):
    if plan =="xy":
        v[:,2]=v[:,2]-min(v[:,2])
    if plan =="xz":
        v[:,1]=v[:,1]-min(v[:,1])
    if plan =="yz":
        v[:,0]=v[:,0]-min(v[:,0])
    return v

def Fusion(*args): #Permet de fusionner tous les stl pour Meshlab
    l = len(args) #Nombre d'élément à fusionner
    
    for i in range(l): #Fusion des éléments
        if i == 0:            
            f,v,n = args[i]
            nv = len(v)
        else:
            f2,v2,n2 = args[i]
            f = np.vstack((f,f2+nv))
            v = np.vstack((v,v2))
            n = np.vstack((n,n2))
            nv = len(v)
    return f,v,n

def RepCirculaire(nom,nb,r,a,axe):                 
    f1,v1,n1=nom
    nv1=len(v1)    
    t=np.linspace(0,a,nb+1)
    t=t[:-1]
    if axe=="z":
        x,y=r*np.cos(t),r*np.sin(t)
        for i in range(len(t)):
            if i != 0:          # ne pas augmenter le f si c'est le premier objet
                f1=np.array(f1+nv1)
            v2=rotation(v1,t[i],axe)
            v2=v2+[x[i],y[i],0] 
            if i ==0:               # pas faire le vstack si c'est le premier objet
                ft=np.array(f1)
                nt=np.array(n1)
                vt=np.array(v2)
            else:
                ft=np.vstack((ft,f1))
                nt=np.vstack((nt,n1))
                vt=np.vstack((vt,v2))
    elif axe=="y":
        x,z=r*np.cos(t),r*np.sin(t)
        for i in range(len(t)):
            if i != 0:          # ne pas augmenter le f si c'est le premier objet
                f1=np.array(f1+nv1)
            v2=rotation(v1,t[i],axe)
            v2=v2+[x[i],0,z[i]] 
            if i ==0:               # pas faire le vstack si c'est le premier objet
                ft=np.array(f1)
                nt=np.array(n1)
                vt=np.array(v2)
            else:
                ft=np.vstack((ft,f1))
                nt=np.vstack((nt,n1))
                vt=np.vstack((vt,v2))
    elif axe=="x":
        y,z=r*np.cos(t),r*np.sin(t)
        for i in range(len(t)):
            if i != 0:          # ne pas augmenter le f si c'est le premier objet
                f1=np.array(f1+nv1)
            v2=rotation(v1,t[i],axe)
            v2=v2+[0,y[i],z[i]] 
            if i ==0:               # pas faire le vstack si c'est le premier objet
                ft=np.array(f1)
                nt=np.array(n1)
                vt=np.array(v2)
            else:
                ft=np.vstack((ft,f1))
                nt=np.vstack((nt,n1))
                vt=np.vstack((vt,v2))
    return ft,vt,nt


