import numpy as np
import struct
from MEC1315_STL import *


def centrer(v): #Permet de centrer le stl en(0,0,0)
    v[:,0]=v[:,0]-(max(v[:,0])+min(v[:,0]))/2 #centre axe x
    v[:,1]=v[:,1]-(max(v[:,1])+min(v[:,1]))/2 #centre axe y
    v[:,2]=v[:,2]-(max(v[:,2])+min(v[:,2]))/2 #centre axe z
    return v

def grandeur(x,y,z,v): #Permet de changer l'échelle du stl (homothétie), Dois utiliser centrer avant
    v[:,0]=v[:,0]/(max(v[:,0])-min(v[:,0]))*x #mise à l'échelle composant x
    v[:,1]=v[:,1]/(max(v[:,1])-min(v[:,1]))*y #mise à l'échelle composant y
    v[:,2]=v[:,2]/(max(v[:,2])-min(v[:,2]))*z #mise à l'échelle composant z
    return v

def emplacement(x,y,z,v): #Permet de déplacer le stl
    v[:,0]=v[:,0]-(max(v[:,0])+min(v[:,0]))/2+x #déplacement en x
    v[:,1]=v[:,1]-(max(v[:,1])+min(v[:,1]))/2+y #déplacement en y
    v[:,2]=v[:,2]-(max(v[:,2])+min(v[:,2]))/2+z #déplacement en z
    return v
    
def rotation(v,angle,axe):
    if axe =="z":
        v=v.dot(np.array([[np.cos(angle),np.sin(angle),0],[-np.sin(angle),np.cos(angle),0],[0,0,1]]))
    elif axe == "y":
        v=v.dot(np.array([[np.cos(angle),0,np.sin(angle)],[0,1,0],[-np.sin(angle),0,np.cos(angle)]]))
    elif axe == "x":
        v=v.dot(np.array([[1,0,0],[0,np.cos(angle),np.sin(angle)],[0,-np.sin(angle),np.cos(angle)]]))
    return v

#fonction fusion à créer
def Fusion(*args):
    l = len(args)
    
    for i in range(l):
        if i == 0:            
            f,v,n = args[i][0], args[i][1], args[i][2]
            nv = len(v)
        else:
            f2,v2,n2 = args[i][0], args[i][1], args[i][2]
            f = np.vstack((f,f2+nv))
            v = np.vstack((v,v2))
            n = np.vstack((n,n2))
            nv = len(v)
    return f,v,n

#--------------------------------------------------

moteur1=LireSTL('moteur1.stl')
moteur2=LireSTL('moteur2.stl')
moteur3=LireSTL('moteur3.stl')
moteur4=LireSTL('moteur4.stl')
moteur5=LireSTL('moteur5.stl')
moteur6=LireSTL('moteur6.stl')
moteur7=LireSTL('moteur7.stl')
moteur8=LireSTL('moteur8.stl')

f,v,n=Fusion(moteur1,moteur2,moteur3,moteur4,moteur5,moteur6,moteur7,moteur8)

moteur123 = Fusion(moteur1,moteur2,moteur2)

F,V,N = moteur123
V = V + [50,1,5]
moteur123[2] = V
moteur123 = F,V,N
#--------------------------------------------------
moteur12345 = Fusion(moteur123,moteur4,moteur5)
F1,V1,N1 = moteur12345

nom_ecrire="moteur_assemble.stl"
# EcrireSTLASCII(nom_ecrire,f,v,n)
#EcrireSTLASCII(nom_ecrire,F,V,N)
EcrireSTLASCII(nom_ecrire,F1,V1,N1)


Répétition ciculaire
#-----------------------------

# -*- coding: utf-8 -*-
"""
Created on Fri Mar  3 12:26:41 2023

@author: chris
"""
import numpy as np
from MEC1315_STL import *



def RepCirculaire(nom,nb,r,a,axe):
    nb1=nb+1
    nom_fichier_in=nom
    f1,v1,n1=LireSTL(nom_fichier_in)
    nv1=len(v1)
    
    t=np.linspace(0,a,nb1)    #mettre arrange ou linspace
    t=t[:-1]
    x,y=r*np.cos(t),r*np.sin(t)

    for i in range(len(t)):
        if i == 0:
            f1=np.array(f1)     # ne pas augmenter le f si c'est le premier objet
        else:
            f1=np.array(f1+nv1)
            
        n2=np.array(n1)
        v2=np.array(v1)
        
        R=Rz(t[i])
        n2=np.dot(n2,R)
        v2=np.dot(v2,R)
                            
        v2=v2+[x[i],y[i],0] 

        if i ==0:               # pas faire le vstack si c'est le premier objet
            ft=np.array(f1)
            nt=np.array(n2)
            vt=np.array(v2)

        else:
            ft=np.vstack((ft,f1))
            nt=np.vstack((nt,n2))
            vt=np.vstack((vt,v2))

    return ft,vt,nt

ft,vt,nt=RepCirculaire('fighter_jet_f18.stl', 7, 200, 2*np.pi, 'z')




nom_out='jetenrond.stl'
EcrireSTLASCII(nom_out, ft, vt, nt)




